# 
msgid ""
msgstr ""
"Project-Id-Version: Fabric\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2015-06-16 16:34+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../usage/parallel.rst:3
msgid "Parallel execution"
msgstr "并行执行"

#: ../usage/parallel.rst:9
msgid ""
"By default, Fabric executes all specified tasks **serially** (see :ref"
":`execution-strategy` for details.) This document describes Fabric's options"
" for running tasks on multiple hosts in **parallel**, via per-task "
"decorators and/or global command-line switches."
msgstr ""
"默认情况下，Fabric 会默认 **顺序** 执行所有任务（详细信息参见 :ref:`execution-strategy` ），"
"这篇文档将介绍 Fabric 如何在多个主机上 **并行** 执行任务，包括 Fabric 参数设置、"
"任务独立的装饰器，以及命令行全局控制。"

#: ../usage/parallel.rst:16
msgid "What it does"
msgstr "它是如何运转的"

#: ../usage/parallel.rst:18
msgid ""
"Because Fabric 1.x is not fully threadsafe (and because in general use, task"
" functions do not typically interact with one another) this functionality is"
" implemented via the Python `multiprocessing "
"<http://docs.python.org/library/multiprocessing.html>`_ module. It creates "
"one new process for each host and task combination, optionally using a "
"(configurable) sliding window to prevent too many processes from running at "
"the same time."
msgstr ""
"由于 Fabric 1.x 并不是完全线程安全（以及为了更加通用，任务函数之间并不会产生交互），"
"该功能的实现是基于 Python `multiprocessing <http://docs.python.org/library/multiprocessing.html>`_ "
"模块，它会为每一个主机和任务组合创建一个线程，同时提供了一个（可选的）弹窗用于阻止"
"创建过多的进程。"

#: ../usage/parallel.rst:26
msgid ""
"For example, imagine a scenario where you want to update Web application "
"code on a number of Web servers, and then reload the servers once the code "
"has been distributed everywhere (to allow for easier rollback if code "
"updates fail.) One could implement this with the following fabfile::"
msgstr ""
"举个例子，假设你正打算更新数台服务器上的 Web 应用代码，所有服务的代码都更新后开始重启服务器"
"（这样代码更新失败的时候比较容易回滚）。你可能会写出下面这样的代码： ::"

#: ../usage/parallel.rst:40
msgid "and execute it on a set of 3 servers, in serial, like so::"
msgstr "在三台服务器上并行执行，就像这样： ::"

#: ../usage/parallel.rst:44
msgid ""
"Normally, without any parallel execution options activated, Fabric would run"
" in order:"
msgstr "刚常见的情况是没有启动任何并行执行参数，Fabric 将会按顺序在服务器上执行： ::"

#: ../usage/parallel.rst:47
msgid "``update`` on ``web1``"
msgstr "在 ``web1`` 上 ``更新``"

#: ../usage/parallel.rst:48
msgid "``update`` on ``web2``"
msgstr "在 ``web2`` 上 ``更新``"

#: ../usage/parallel.rst:49
msgid "``update`` on ``web3``"
msgstr "在 ``web3`` 上 ``更新``"

#: ../usage/parallel.rst:50
msgid "``reload`` on ``web1``"
msgstr "在 ``web1`` 上 ``重新加载配置``"

#: ../usage/parallel.rst:51
msgid "``reload`` on ``web2``"
msgstr "在 ``web2`` 上 ``重新加载配置``"

#: ../usage/parallel.rst:52
msgid "``reload`` on ``web3``"
msgstr "在 ``web3`` 上 ``重新加载配置``"

#: ../usage/parallel.rst:54
msgid ""
"With parallel execution activated (via :option:`-P` -- see below for "
"details), this turns into:"
msgstr "如果激活并行执行（通过 :option:`-P` ——下面会详细介绍）它将变成这样："

#: ../usage/parallel.rst:57
msgid "``update`` on ``web1``, ``web2``, and ``web3``"
msgstr "在 ``web1``、``web3`` 和 ``web3`` 上 ``更新``"

#: ../usage/parallel.rst:58
msgid "``reload`` on ``web1``, ``web2``, and ``web3``"
msgstr "在 ``web1``、``web2`` 和 ``web3`` 上 ``重新加载配置``。"

#: ../usage/parallel.rst:60
msgid ""
"Hopefully the benefits of this are obvious -- if ``update`` took 5 seconds "
"to run and ``reload`` took 2 seconds, serial execution takes (5+2)*3 = 21 "
"seconds to run, while parallel execution takes only a third of the time, "
"(5+2) = 7 seconds on average."
msgstr ""
"这样做的好处非常明显——如果 ``update`` 花费 5 秒 ``reload`` 花费 2  秒"
"顺序执行总共会花费 (5+2)*3 = 21 秒，而并行执行只需要它的 1/3，也就是 (5+2) = 7 秒。"

#: ../usage/parallel.rst:67
msgid "How to use it"
msgstr "如何使用"

#: ../usage/parallel.rst:70
msgid "Decorators"
msgstr "装饰器"

#: ../usage/parallel.rst:72
msgid ""
"Since the minimum \"unit\" that parallel execution affects is a task, the "
"functionality may be enabled or disabled on a task-by-task basis using the "
"`~fabric.decorators.parallel` and `~fabric.decorators.serial` decorators. "
"For example, this fabfile::"
msgstr ""
"由于并行执行影响的最小单位是任务，所以功能的启用或禁用也是以任务为单位使用 "
"`~fabric.decorators.parallel` 或 `~fabric.decorators.serial` 装饰器。"
"以下面这个 fabfile 为例： ::"

#: ../usage/parallel.rst:86
msgid "when run in this manner::"
msgstr "如果这样执行： ::"

#: ../usage/parallel.rst:90
msgid "will result in the following execution sequence:"
msgstr "将会按照这样的流程执行："

#: ../usage/parallel.rst:92
msgid "``runs_in_parallel`` on ``host1``, ``host2``, and ``host3``"
msgstr "``runs_in_parallel`` 运行在 ``host1``、``host2`` 和 ``host3`` 上"

#: ../usage/parallel.rst:93
msgid "``runs_serially`` on ``host1``"
msgstr "``runs_serially`` 运行在 ``host1`` 上"

#: ../usage/parallel.rst:94
msgid "``runs_serially`` on ``host2``"
msgstr  "``runs_serially`` 运行在 ``host2`` 上"

#: ../usage/parallel.rst:95
msgid "``runs_serially`` on ``host3``"
msgstr  "``runs_serially`` 运行在 ``host3`` 上"

#: ../usage/parallel.rst:98
msgid "Command-line flags"
msgstr "命令行参数"

#: ../usage/parallel.rst:100
msgid ""
"One may also force all tasks to run in parallel by using the command-line "
"flag :option:`-P` or the env variable :ref:`env.parallel <env-parallel>`.  "
"However, any task specifically wrapped with `~fabric.decorators.serial` will"
" ignore this setting and continue to run serially."
msgstr ""
"你也可以使用命令行选项 :option:`-P` 或者环境变量 :ref:`env.parallel <env-parallel>"
"强制所有任务并行执行。不过被装饰器 `~fabric.decorators.serial` 封装的任务会忽略该设置，"
"仍旧保持顺序执行。"

#: ../usage/parallel.rst:105
msgid ""
"For example, the following fabfile will result in the same execution "
"sequence as the one above::"
msgstr "例如，下面的 fabfile 会产生和上面同样的执行顺序： ::"

#: ../usage/parallel.rst:117
msgid "when invoked like so::"
msgstr "在这样调用时： ::"

#: ../usage/parallel.rst:121
msgid ""
"As before, ``runs_in_parallel`` will run in parallel, and ``runs_serially`` "
"in sequence."
msgstr "和上面一样，``runs_in_parallel`` 将会并行执行，``runs_serially`` 顺序执行。"

#: ../usage/parallel.rst:126
msgid "Bubble size"
msgstr "bubble 大小"

#: ../usage/parallel.rst:128
msgid ""
"With large host lists, a user's local machine can get overwhelmed by running"
" too many concurrent Fabric processes. Because of this, you may opt to use a"
" moving bubble approach that limits Fabric to a specific number of "
"concurrently active processes."
msgstr ""
"主机列表很大时，用户的机器可能会因为并发运行了太多的 Fabric 进程而被压垮，"
"因此，你可能会选择 moving bubble 方法来限制 Fabric 并发执行的活跃进程数。"

#: ../usage/parallel.rst:133
msgid ""
"By default, no bubble is used and all hosts are run in one concurrent pool. "
"You can override this on a per-task level by specifying the ``pool_size`` "
"keyword argument to `~fabric.decorators.parallel`, or globally via "
":option:`-z`."
msgstr ""
"默认情况下没有使用 bubble 限制，所有主机都运行在并发池中。你可以在任务级别指定 "
" `~fabric.decorators.parallel` 的关键字参数 ``pool_size`` 来覆盖该设置，"
"或者使用选项 :option:`-z` 全局设置。"

#: ../usage/parallel.rst:137
msgid "For example, to run on 5 hosts at a time::"
msgstr "例如同时在 5 个主机上运行： ::"

#: ../usage/parallel.rst:145
msgid "Or skip the ``pool_size`` kwarg and instead::"
msgstr "或者不使用关键字参数 ``pool_size``： ::"

#: ../usage/parallel.rst:152
msgid "Linewise vs bytewise output"
msgstr ""

#: ../usage/parallel.rst:154
msgid ""
"Fabric's default mode of printing to the terminal is byte-by-byte, in order "
"to support :doc:`/usage/interactivity`. This often gives poor results when "
"running in parallel mode, as the multiple processes may write to your "
"terminal's standard out stream simultaneously."
msgstr ""
"为了支持 :doc:`/usage/interactivity` 特性，Fabric 默认会一字节一字节地讲数据输出到终端。"
"并行情况下，这样的输出结果会非常糟糕，因为多个进程的同时输出结果可能会混在终端的标准输出流中。"

#: ../usage/parallel.rst:159
msgid ""
"To help offset this problem, Fabric's option for linewise output is "
"automatically enabled whenever parallelism is active. This will cause you to"
" lose most of the benefits outlined in the above link Fabric's remote "
"interactivity features, but as those do not map well to parallel "
"invocations, it's typically a fair trade."
msgstr ""
"为了消除该问题，在并行执行时 Fabric 会自动启用行级输出，这会导致上面链接中提到的"
"远程交互特性大部分失效，不过这是一个合理的折中。"

#: ../usage/parallel.rst:165
msgid ""
"There's no way to avoid the multiple processes mixing up on a line-by-line "
"basis, but you will at least be able to tell them apart by the host-string "
"line prefix."
msgstr ""
"行级输出混淆的情况在多进程的情况下是无法避免的，但是你可以设置主机地址作为前缀来区分。"

#: ../usage/parallel.rst:170
msgid ""
"Future versions will add improved logging support to make troubleshooting "
"parallel runs easier."
msgstr "未来版本会增加增强的日志支持来简化并行运行情况下的问题追踪。"
